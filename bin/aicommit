#!/usr/bin/env bash
set -euo pipefail

OPENAI_API_KEY=${OPENAI_API_KEY:-sk-fly-}
BASE_URL="${OPENAI_BASE_URL:-https://api.llmgate.dev}"
MODEL="${OPENAI_MODEL:-gpt-5.2-codex-mini}"
TEMP="${OPENAI_TEMPERATURE:-0.2}"
MAX="${MAX_DIFF_CHARS:-12000}"

RE='^(feat|fix|build|chore|ci|docs|style|refactor|perf|test|revert)(\([a-zA-Z0-9._/-]+\))?(!)?: .+'

ADD_ALL=false
NO_CONFIRM=false
DO_PUSH=false

# ---------------- FLAGS (-ayp / --all --no-confirm --push) ----------------
for arg in "$@"; do
  case "$arg" in
    --all) ADD_ALL=true ;;
    --no-confirm) NO_CONFIRM=true ;;
    --push) DO_PUSH=true ;;
    -[!-]*)
      for (( i=1; i<${#arg}; i++ )); do
        case "${arg:i:1}" in
          a) ADD_ALL=true ;;
          y) NO_CONFIRM=true ;;
          p) DO_PUSH=true ;;
          *) echo "Unknown flag: -${arg:i:1}" >&2; exit 1 ;;
        esac
      done
      ;;
  esac
done

# ---------------- HIRES TIMER (mac-friendly, no heredoc-on-stdin) ----------------
now() {
  if command -v python3 >/dev/null 2>&1; then
    python3 -c 'import time; print(time.time())'
  else
    perl -MTime::HiRes=time -e 'print time'
  fi
}

elapsed() {
  # args: t0 t1 -> prints float seconds
  local t0="$1" t1="$2"
  if command -v python3 >/dev/null 2>&1; then
    python3 -c 'import sys; t0=float(sys.argv[1]); t1=float(sys.argv[2]); print(t1-t0)' "$t0" "$t1"
  else
    perl -e 'my ($t0,$t1)=@ARGV; print($t1-$t0);' "$t0" "$t1"
  fi
}

fmt_secs() {
  # input: float seconds (from stdin)
  if command -v python3 >/dev/null 2>&1; then
    python3 -c 'import sys; x=float(sys.stdin.read().strip() or 0); print(f"{x:.1f}s")'
  else
    perl -e 'chomp($x=<STDIN>); $x=0+$x; printf("%.1fs",$x)'
  fi
}

# ---------------- SPINNER (one-line) ----------------
SPIN_PID=""
SPIN_MSG=""

spinner_start() {
  SPIN_MSG="${1:-Working...}"
  local frames='|/-\'
  (
    local i=0
    while :; do
      printf "\r%s %c" "$SPIN_MSG" "${frames:i%${#frames}:1}"
      i=$((i+1))
      sleep 0.12
    done
  ) &
  SPIN_PID=$!
}

spinner_stop_line() {
  local suffix="${1:-}"
  if [[ -n "${SPIN_PID:-}" ]]; then
    kill "$SPIN_PID" 2>/dev/null || true
    wait "$SPIN_PID" 2>/dev/null || true
  fi
  SPIN_PID=""
  printf "\r\033[K%s%s\n" "$SPIN_MSG" "$suffix"
}

cleanup() {
  if [[ -n "${SPIN_PID:-}" ]]; then
    kill "$SPIN_PID" 2>/dev/null || true
    wait "$SPIN_PID" 2>/dev/null || true
  fi
  SPIN_PID=""
}
trap 'cleanup; echo; exit 130' INT
trap 'cleanup' EXIT TERM

# ---------------- JOKES ----------------
J_ADD=(
  "Đang gom nhặt mảnh vỡ…"
  "Đang dọn bãi chiến trường…"
  "Đang ‘git add’ với niềm tin…"
  "Đang nhặt từng dòng như nhặt lá…"
)
J_DIFF=(
  "Đang soi diff dưới kính hiển vi…"
  "Đang đọc ‘tâm thư’ của staged changes…"
  "Đang kiểm tra xem bạn có lỡ tay không…"
  "Đang tìm xem có bug nào lẩn trốn…"
)
J_AI=(
  "Đang tìm lý do cho mớ code này…"
  "Đang giải thích sự hỗn loạn…"
  "Đang bịa commit một cách chuyên nghiệp…"
  "Đang cố hiểu bạn vừa làm gì…"
  "Đang biến panic thành commit…"
)
J_FIX=(
  "Đang nắn commit cho đúng chuẩn…"
  "Đang dũa câu chữ cho ‘Conventional’…"
  "Đang vá format…"
)
J_COMMIT=(
  "Đang khắc commit lên bia đá…"
  "Đang chốt hạ lịch sử…"
  "Đang ‘git commit’ với sự nghiêm túc giả…"
)
J_PUSH=(
  "Đang đẩy lên trời…"
  "Đang phóng commit lên origin…"
  "Đang gửi hàng qua không gian…"
  "Đang bắn thay đổi ra internet…"
)

pick() {
  local arr_name="$1"
  eval "local n=\${#${arr_name}[@]}"
  local idx=$((RANDOM % n))
  eval "printf '%s' \"\${${arr_name}[$idx]}\""
}

# ---------------- STEP RUNNER ----------------
run_step() {
  local msg="$1"
  shift

  local t0 t1 dt
  t0="$(now)"
  spinner_start "$msg"

  # keep commands quiet; if fail show stderr
  local err
  err="$(mktemp)"
  if "$@" >/dev/null 2>"$err"; then
    t1="$(now)"
    dt="$(elapsed "$t0" "$t1")"
    spinner_stop_line " (Done $(printf "%s" "$dt" | fmt_secs))"
    rm -f "$err"
    return 0
  else
    spinner_stop_line " (Fail)"
    echo "---- error ----" >&2
    sed 's/^/  /' "$err" >&2 || true
    echo "--------------" >&2
    rm -f "$err"
    return 1
  fi
}

# ---------------- AI CALL ----------------
system=$'write a git commit message strictly following conventional commits v1.0.0.\n\n- plain text only\n- use lowercase letters only (no uppercase characters anywhere)\n- first line: type(scope)!: subject\n- type ∈ feat|fix|build|chore|ci|docs|style|refactor|perf|test|revert\n- subject imperative, <=72 chars, no trailing period\n- add body/footer only if needed\n- do not invent changes.'

call_ai() {
  local usr="$1"
  local payload resp out

  payload="$(
    jq -n \
      --arg m "$MODEL" \
      --arg sys "$system" \
      --arg usr "$usr" \
      --argjson t "$TEMP" \
      '{
        model: $m,
        temperature: $t,
        messages: [
          { role:"system", content: $sys },
          { role:"user",   content: $usr }
        ]
      }'
  )"

  # Prefer Chat Completions (most gateways support it)
  resp="$(
    curl --fail-with-body -sS \
      "$BASE_URL/v1/chat/completions" \
      -H "Authorization: Bearer $OPENAI_API_KEY" \
      -H "Content-Type: application/json" \
      -d "$payload"
  )" || {
    echo "AI HTTP error:" >&2
    echo "$resp" >&2
    return 1
  }

  # Extract output or show API error
  out="$(
    printf "%s" "$resp" | jq -r '
      if .error? then
        "ERROR: \(.error.message // .error)" | halt_error(1)
      elif .choices? then
        (.choices[0].message.content // "")
      elif .output? then
        (
          [ .output[]?
            | select(.type=="message")
            | .content[]?
            | select(.type=="output_text")
            | .text
          ] | join("")
        )
      else
        ""
      end
    '
  )" || {
    echo "AI parse/API error response:" >&2
    echo "$resp" >&2
    return 1
  }

  printf "%s" "$out" | sed 's/\r$//'
}


# ---------------- MAIN ----------------
# 1) add
if $ADD_ALL; then
  run_step "$(pick J_ADD)" git add -A
fi

# 2) staged diff
diff="$(git diff --staged || true)"
[[ -n "$diff" ]] || { echo "No staged changes."; exit 0; }
diff="${diff:0:$MAX}"

# purely UX line (instant)
run_step "$(pick J_DIFF)" bash -c 'exit 0'

user="Staged diff:\n$diff"

# 3) AI generate (needs stdout => manual timing)
t0="$(now)"
spinner_start "$(pick J_AI)"
msg="$(call_ai "$user" || true)"
t1="$(now)"
dt="$(elapsed "$t0" "$t1")"
spinner_stop_line " (Done $(printf "%s" "$dt" | fmt_secs))"

[[ -n "${msg:-}" ]] || { echo "Empty AI response"; exit 1; }

# 4) validate + fix format if needed
first="$(head -n1 <<<"$msg")"
if ! [[ "$first" =~ $RE ]]; then
  t0="$(now)"
  spinner_start "$(pick J_FIX)"
  msg="$(call_ai $'Fix ONLY formatting to match Conventional Commits v1.0.0.\nReturn plain text only.\n\nDraft:\n'"$msg" || true)"
  t1="$(now)"
  dt="$(elapsed "$t0" "$t1")"
  spinner_stop_line " (Done $(printf "%s" "$dt" | fmt_secs))"

  first="$(head -n1 <<<"$msg")"
  [[ "$first" =~ $RE ]] || { echo "Invalid Conventional Commit: $first"; exit 1; }
fi

echo "-------------------------"
echo "$msg"
echo "-------------------------"

# 5) confirm
if ! $NO_CONFIRM; then
  read -r -p "Commit? [y/N] " yn
  [[ "$yn" =~ ^[Yy]$ ]] || exit 0
fi

# 6) commit (quiet git)
tmp="$(mktemp)"
printf "%s\n" "$msg" > "$tmp"
run_step "$(pick J_COMMIT)" git commit -F "$tmp"
rm -f "$tmp"

# 7) push (quiet git)
if $DO_PUSH; then
  branch="$(git rev-parse --abbrev-ref HEAD)"
  run_step "$(pick J_PUSH) (origin $branch)" git push origin "$branch"
fi